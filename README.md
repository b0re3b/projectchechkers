# projectchechkers
Київський національний університет імені Тараса Шевченка

Факультет компʼютерних наук та кібернетики

Кафедра інтелектуальних програмних систем

Основи обʼєктно-орієнтованого програмування











Проектна робота: 

«Шашки з елементами штучного інтелекту»

Виконав студент 2-го курсу

Групи ІПС-22

Решетько Богдан Олександрович

















Київ - 2023 
Завдання: Написати просту гру в шахи. Ми маємо два гравця, один з них це ми, інший компʼютер.

Мова реалізації: С++.

Як програма має працювати: Програма є простою грою в шашки, між компʼютером та людиною. Для компʼютера ми використовуємо алгоритм мінімаксу для знаходження найкращого ходу. Людина сама вибирає куди їй ходити.

Про алгоритм:
Щоб зрозуміти, як функціонує правило мінімаксу, необхідно зрозуміти логіку гравців:
У деяких іграх поразка виражається числом, наприклад, грошовою втратою після гри. В інших випадках поразка просто вказує, хто переміг і хто програв.
Кожен інший гравець робить рішення, що можуть збільшити вашу максимальну можливу втрату. Наприклад, через його дії ви можете втратити 10 або 500 очок. Максимальна можлива втрата в цьому випадку – 500 очок.
Мета полягає в тому, щоб на кожному кроці приймати рішення, що зменшує цю втрату. Інакше кажучи, навіть якщо втрата відбувається, то не 500, а 10 – мінімальна з можливих варіантів.
Правило мінімаксу визначає стратегію, що мінімізує максимально можливу втрату. Ознака такої стратегії виглядає так:
Це найкраща мінімаксна стратегія, бо найгірший можливий варіант в ній значно кращий за найгірший в інших стратегіях.

Додаткові бібліотеки: Для зручності та простоти у цій програмі я використовував бібліотеку SFML, з якою знайомився вперше. Як на мене вона є досить легкою та зрозумілою для сприйняття. В інтернеті не достатньо даних для її вивчення, але й технічної документації вистачить сповна.

Модулі програми:

Загалом програма складається з класів: 
class Move що відповідає за зберігання даних про конкретний хід
class MoveNode створення структури для зберігання даних про хід та його оцінку в контексті алгоритму мінімакс
class Piece відповідає за збереження фігур у грі
class Player відповідає за збереження гравців
class Board відповідає за управління грою

Та функцій:
void InitializeGame ініціалізує дошку та шашки, розставляє їх по місцях
  bool validarity перевіряє чи доступний хід: Функція validarity перевіряє, чи хід, заданий параметрами startX, startY, endX і endY, є допустимим. Хід вважається допустимим, якщо:
startX і startY є допустимими індексами на дошці.
endX і endY також є допустимими індексами на дошці.
Piece на позиції (startX, startY) належить гравцеві, який робить хід.
Хід є ходом на одну або дві клітинки в напрямку вперед (верх або вниз), якщо Piece на позиції (startX, startY) не є королем.
Хід є ходом на одну або дві клітинки в напрямку вперед і вбік, якщо Piece на позиції (startX, startY) є королем.
Якщо хід є стрибком, то на позиції (endX, endY) не повинно бути жодної фігури.
Якщо хід є допустимим, функція validarity повертає значення true, інакше вона повертає значення false.

void inputdata Перевіряє, чи був клік миші на дошці.
Визначає, яка фігура була виділена.
Отримує позиції кінцевої клітинки, на яку користувач хоче перемістити фігуру.
Перевіряє, чи хід є допустимим.
Якщо хід є допустимим, виконує його і оновлює стан гри.
Якщо хід не є допустимим, видає повідомлення про помилку.

 void highlight Отримує позиції обраної фігури.
Перевіряє, чи є хід на одну або дві клітинки в напрямку вперед (верх або вниз), якщо фігура не є королем.
Перевіряє, чи є хід на одну або дві клітинки в напрямку вперед і вбік, якщо фігура є королем.
Якщо хід є допустимим, виділяє клітинку, на яку можна зробити хід.
int numberofmoves Отримує колір гравця.
Перебирає всі фігури на дошці.
Для кожної фігури перевіряє, чи є хід на одну або дві клітинки в напрямку вперед (верх або вниз), якщо фігура не є королем.
Для кожної фігури перевіряє, чи є хід на одну або дві клітинки в напрямку вперед і вбік, якщо фігура є королем.
Якщо хід є допустимим, збільшує лічильник кількості ходів на одиницю.

bool endgame перевіряє гру на завершення

 void draw малює полотно гри

int evaluateBoard Підраховує кількість фігур для кожного гравця.
Підраховує кількість королів для кожного гравця.
Підраховує кількість фігур, які можуть зробити хід, для кожного гравця.

 MoveNode MinMaxTree Створює корінний вузол дерева для заданого стану.
Перебирає всіх гравців.
Для кожного гравця:
Перебирає всі можливі ходи для цього гравця.
Для кожного ходу:
Створює новий вузол дерева для нового стану.
Обчислює оцінку нового стану.
Додає новий вузол до дерева.
Move BestMove Побудуйте мінімаксне дерево для заданого стану.
Почніть з корінного вузла дерева.
Якщо вузол є листям, поверніть його оцінку.
Інакше:
Якщо гравець, який робить хід, є максимальним, знайдіть максимальну оцінку в дочірніх вузлах.
Якщо гравець, який робить хід, є мінімальним, знайдіть мінімальну оцінку в дочірніх вузлах.
Поверніть оцінку, знайдену на попередньому кроці.
 bool opponentPiece Отримує позиції клітинки.
Отримує колір гравця, який робить хід.
Перебирає всі фігури на дошці.
Для кожної фігури:
Якщо фігура знаходиться на заданій клітинці.
Якщо колір фігури не дорівнює кольору гравця, який робить хід.Повертає фігуру.

std::vector<Move> generateMoves Функція generateMoves виконує такі дії:
Отримує колір гравця, який робить хід.
Перебирає всі фігури на дошці.
Для кожної фігури:
Якщо фігура належить заданому гравцеві.
Якщо фігура може зробити хід.
Додайте хід до списку можливих ходів.
Функція generateMoves повертає список можливих ходів.

int minimax сам рекурсивний алгоритм мінімаксу

 void ComputerMove виконує хід компʼютера

int MousePosition визначає положення мишки на дошці 

 void makeMove робить хід

Можливості покращення:
Наразі проргама має майже всі функціональні рішення, та логіку. Проте вона не повністю виконується, бо має деякі помилки. Тому, в наступному семестрі я маю в планах написати unit tests для кожного блоку програми для перевірки чи використовується він по задуму. Покращити user interface, що включає в себе меню гри з вибором кольору гравця та складності. Покращення алгоритму до alpha-beta алгоритму що значно посилить наш штучний інтелект та інше.
Використані джерела:
https://www.youtube.com/watch?v=mYbrH1Cl3nw
https://www.youtube.com/watch?v=EnYui0e73Rs&list=PLBwF487qi8MGU81nDGaeNE1EnNEPYWKY_
https://www.youtube.com/watch?v=x-4wr_FGYZM
https://github.com/Rachid-AYM/Projects/blob/main/Checkers/main.cpp
https://github.com/Rachid-AYM/Projects/blob/main/Checkers/main.cpp
https://stackoverflow.com/questions/55695153/issue-with-double-jumping
https://www.youtube.com/watch?v=mYbrH1Cl3nw&t=9s
https://www.youtube.com/watch?v=RjdrFHEgV2o
https://www.youtube.com/watch?v=l_wOsSda3Us
https://www.youtube.com/watch?v=_kOXGzkbnps&t=3090s
https://youtube.com/watch?v=LSYj8GZMjWY&t=8s
https://www.youtube.com/watch?v=OpL0Gcfn4B4&t=5957s
https://github.com/erik-lance/Checkers-Chess-AI
https://github.com/DevonMcGrath/Java-Checkers 
Та інші.
