<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lab 2: Programming patterns in main project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lab 2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Programming patterns in main project </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2_users_2bogdanresetko_2loh_2usingpatern"></a>Its a part of Lab 2, it contains 4 of 8 patterns.</p>
<p>All program code files are in the repository(<a href="https://github.com/b0re3b/projectchechkers">https://github.com/b0re3b/projectchechkers</a>), also you can check general documentation to this program.</p>
<p>Using design patterns helps developers create more structured, flexible, and easily maintainable programs. Patterns provide standard solutions to common problems, avoiding ad-hoc solutions and improving code readability. They also help reduce dependencies between program components and enhance code reuse. Utilizing patterns reduces the risk of errors and simplifies component testing, while also improving system scalability.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
MVC(Model-View-Controller)</h2>
<p>This program follows the Model-View-Controller (MVC) paradigm, which helps divide the program into three main components: model, view, and controller. The model is responsible for managing data and the business logic of the program. In my program, the model is represented by the classes <a class="el" href="class_player.html" title="Class representing a player in the game.">Player</a>, <a class="el" href="class_piece.html" title="Represents a checker piece on the board.">Piece</a>, and <a class="el" href="class_board.html" title="Represents the game board and its functionality.">Board</a>, which represent players, pieces, and the game board, respectively. The GameLoop class manages the game state and interacts with other model objects.</p>
<p>Some functions are declared in the <a class="el" href="class_board.html" title="Represents the game board and its functionality.">Board</a> class due to the specifics of the SFML library, but their implementation occurs in other classes. Similarly, the view functions for displaying objects are declared in their respective classes but implemented in the drawobjects file. Overall, the program meets all requirements for separating models from their representation and the controller.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Facade</h2>
<p>In my program, I use the facade pattern to make it easier to understand and manage. For this, I've created a separate class <code><a class="el" href="class_game_facade.html" title="Class representing the main game facade.">GameFacade</a></code>, which gathers all the components necessary to start the game. This allows me to avoid bulky and complex code in the main <code>main</code> file and provides greater structure to my code.</p>
<p>Instead of having detailed instructions for setting up players and other complex processes directly in the main file, I use <code><a class="el" href="class_game_facade.html" title="Class representing the main game facade.">GameFacade</a></code>. This makes my main file less cluttered and more understandable.</p>
<p>Moreover, thanks to the Facade pattern, users can easily start the game without understanding all the details of the internal implementation. They simply create an instance of <code><a class="el" href="class_game_facade.html" title="Class representing the main game facade.">GameFacade</a></code> and call the <code>runGame()</code> method, making the interaction with the program more enjoyable and understandable.</p>
<p>Thus, using the Facade pattern allows me to simplify the interaction with the program and provide a convenient interface for users. </p>
<h3><a class="anchor" id="autotoc_md3"></a>
State</h3>
<p>In my program, I use the State pattern to manage different states of <a class="el" href="class_piece.html" title="Represents a checker piece on the board.">Piece</a> objects without the need to change their interface. This allows me to replace the logic of handling states in the <a class="el" href="class_piece.html" title="Represents a checker piece on the board.">Piece</a> object without changing the object itself.</p>
<p>When a piece transitions into different states, such as regular or king, it automatically changes its behavior according to the logic defined for that state. For example, if a piece becomes a king, it gains new movement and attack capabilities.</p>
<p>In my program, there are two classes, <a class="el" href="class_regular_state.html" title="Concrete class representing the state of a regular piece.">RegularState</a> and <a class="el" href="class_king_state.html" title="Concrete class representing the state of a king piece.">KingState</a>, representing different states of pieces. Each of these classes contains its own implementation of movement and attack methods according to the type of piece.</p>
<p>The <a class="el" href="class_piece.html" title="Represents a checker piece on the board.">Piece</a> class contains a reference to an object of the <a class="el" href="class_piece_state.html" title="Abstract base class for defining the state of a piece.">PieceState</a> class, representing the current state of the piece. When the state of the <a class="el" href="class_piece.html" title="Represents a checker piece on the board.">Piece</a> object changes to <a class="el" href="class_regular_state.html" title="Concrete class representing the state of a regular piece.">RegularState</a> or <a class="el" href="class_king_state.html" title="Concrete class representing the state of a king piece.">KingState</a>, the invoked methods will automatically be delegated to the corresponding state classes.</p>
<p>This approach allows me to keep the logic of handling piece states separate from the <a class="el" href="class_piece.html" title="Represents a checker piece on the board.">Piece</a> object itself, making the code more modular and convenient for extension.</p>
<p>After using the State pattern, the program became more flexible and supports easier extension. Now it's possible to add new states to pieces without changing the core logic of the <a class="el" href="class_piece.html" title="Represents a checker piece on the board.">Piece</a> class. This enhances modularity and maintainability of the code.</p>
<p>Additionally, applying the State pattern simplifies working with object states. Now, when a piece changes its state, it automatically receives the corresponding movement and attack logic defined for that state. This makes the code more understandable and less error-prone.</p>
<p>Moreover, using the pattern allows leveraging the principle of polymorphism for handling different types of pieces, enhancing readability and expanding the program's capabilities. </p>
<h2><a class="anchor" id="autotoc_md4"></a>
Observer</h2>
<p>In my program, the <a class="el" href="class_observer.html" title="Interface for observers that wish to be notified of changes.">Observer</a> pattern is used to organize the observation of objects. When input data changes its state, a message is sent to the <a class="el" href="class_board.html" title="Represents the game board and its functionality.">Board</a> class, and then all other classes are notified. I use this pattern to ensure automatic game updates when the board state changes. For example, when a player makes a move, all other objects that display the game state are automatically updated to reflect the new board state.</p>
<p>The <a class="el" href="class_subject.html" title="Subject class that observes changes and notifies observers.">Subject</a> class (or Observable) in my program is represented by a class responsible for the game or board state. It contains a list of observers and provides methods for attaching, detaching, and notifying observers of changes.</p>
<p>The <a class="el" href="class_observer.html" title="Interface for observers that wish to be notified of changes.">Observer</a> class defines the observer interface, which includes the update method. In my program, a specific observer is implemented to handle game updates.</p>
<p>When the game state changes, such as when a player makes a move, the <a class="el" href="class_subject.html" title="Subject class that observes changes and notifies observers.">Subject</a> class (board) notifies all registered observers by calling their update method. This allows all objects that display the game state to automatically update and reflect the new state. </p>
<h2><a class="anchor" id="autotoc_md5"></a>
Summary</h2>
<p>Overall, working on the lab was interesting and made my program much more flexible, also improving its functionality. These patterns provided us with a better understanding of piece states (thanks to the State pattern), better awareness of the situation on the board (<a class="el" href="class_observer.html" title="Interface for observers that wish to be notified of changes.">Observer</a> pattern), improved visual perception of the main program file (Facade pattern), and made component separation in MVC work better. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
